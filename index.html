<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binance Futures — Euphoric Stage Detector (USDT-Perps) — Safe</title>
  <style>
    body { font-family: Inter, system-ui, Arial; margin:16px; background:#0f172a; color:#e6eef8; }
    h1{ font-size:20px; margin-bottom:8px }
    .controls{ display:flex; gap:8px; align-items:center; margin-bottom:12px; flex-wrap:wrap }
    label{ font-size:13px; color:#cbd5e1 }
    input, select, button { padding:6px 8px; border-radius:6px; border:1px solid #273449; background:#071126; color:#e6eef8 }
    table{ width:100%; border-collapse: collapse; margin-top:12px; }
    th,td{ text-align:left; padding:8px; border-bottom:1px solid #112233; font-size:13px }
    th{ color:#94a3b8; font-weight:600; background:#071526; position:sticky; top:0 }
    .green{ color:#7ef1a1; font-weight:700 }
    .red{ color:#ff9aa2; font-weight:700 }
    .badge { padding:4px 8px; border-radius:999px; font-size:12px; background:#102233; color:#e6eef8; border:1px solid #183543 }
    .eup{ background: linear-gradient(90deg,#0a6fff22,#00d09b22); color:#7ef1a1; font-weight:800; border:1px solid #0aa87a }
    .small{ font-size:12px; color:#9fb0c9 }
    .info{ margin-top:10px; color:#9fb0c9; font-size:13px }
    .hint{ font-size:12px; color:#9fb0c9; margin-left:8px }
  </style>
</head>
<body>
  <h1>Binance Futures — Euphoric Stage Detector (USDT Perps)</h1>

  <div class="controls">
    <label>
      Min daily gain %:
      <input id="minDailyGain" type="number" step="0.1" value="3" style="width:80px" />
    </label>
    <label>
      Min 7d gain %:
      <input id="min7dGain" type="number" step="0.1" value="7" style="width:80px" />
    </label>
    <label>
      Funding threshold (decimal):
      <input id="fundingThreshold" type="number" step="0.0001" value="0.001" style="width:100px" />
    </label>
    <label>
      Top-N 24h gainers:
      <input id="topN" type="number" value="10" min="1" max="50" style="width:60px" />
    </label>

    <label><input id="useProxy" type="checkbox" /> Use CORS proxy (for testing)</label>
    <label><input id="autoRefresh" type="checkbox" /> Auto Refresh</label>

    <button id="runBtn">Run scan</button>
    <div id="status" class="small" style="margin-left:12px">idle</div>
    <div class="hint">Cooldown: 15s · per-symbol pause ≈350–550ms</div>
  </div>

  <div class="info">
    This safer version reduces chance of hitting Binance rate limits by batching, caching, jittered pauses, and retry/backoff.
  </div>

  <table id="results">
    <thead>
      <tr>
        <th>Symbol</th>
        <th>24h %</th>
        <th>7d %</th>
        <th>Funding</th>
        <th>Open Interest</th>
        <th>Volume (24h)</th>
        <th>Signals</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
  (function(){
    const $ = id => document.getElementById(id);
    const runBtn = $('runBtn');
    const statusEl = $('status');
    const resultsTbody = document.querySelector('#results tbody');

    const BASE = 'https://fapi.binance.com';
    function apiUrl(path){
      const useProxy = $('useProxy').checked;
      const url = BASE + path;
      if(!useProxy) return url;
      // Quick demo proxy for testing only
      return 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
    }

    function setStatus(txt){ statusEl.textContent = txt; }

    // ---- Safety controls ----
    let lastScan = 0;
    const SCAN_COOLDOWN_MS = 15000; // 15s cooldown between scans
    const CACHE_TTL_MS = 10000; // 10s cache for exchangeInfo and tickers

    // simple in-memory cache
    const cache = {
      exchangeInfo: { ts: 0, data: null },
      tickers24h: { ts: 0, data: null }
    };

    // pause with jitter to avoid pattern throttling (min,max ms)
    function pauseJitter(min=350, max=550){
      const d = Math.floor(Math.random() * (max - min + 1)) + min;
      return new Promise(res => setTimeout(res, d));
    }

    // exponential backoff + jittered safe fetch
    async function safeFetch(url, opts = {}, retries = 4){
      try {
        const r = await fetch(url, opts);
        if (r.status === 429 || (r.status >= 500 && r.status < 600)) {
          // rate-limited or server error — try again with backoff
          if (retries > 0) {
            const backoffBase = 300; // ms
            const attempt = (5 - retries);
            const wait = backoffBase * Math.pow(2, attempt) + Math.floor(Math.random() * 300);
            console.warn(`safeFetch: ${r.status} for ${url} — retrying in ${wait}ms (${retries-1} left)`);
            await new Promise(res => setTimeout(res, wait));
            return safeFetch(url, opts, retries - 1);
          } else {
            throw new Error('Rate limit or server error and retries exhausted (status ' + r.status + ')');
          }
        }
        if (!r.ok) {
          throw new Error('HTTP ' + r.status + ' ' + r.statusText);
        }
        const contentType = r.headers.get('content-type') || '';
        if (contentType.includes('application/json') || contentType.includes('text/plain') || contentType.includes('text/json')) {
          return await r.json();
        } else {
          // fallback: try text
          const txt = await r.text();
          try { return JSON.parse(txt); } catch(e){ return txt; }
        }
      } catch (err) {
        // network or parse error
        if (retries > 0) {
          const wait = 500 + Math.floor(Math.random() * 500);
          console.warn('safeFetch network error, retrying', err, 'wait', wait);
          await new Promise(res => setTimeout(res, wait));
          return safeFetch(url, opts, retries - 1);
        }
        throw err;
      }
    }

    // wrapper which shows a nicer error message on failures
    async function fetchJson(url){
      try {
        return await safeFetch(url);
      } catch (err) {
        throw new Error(err.message + ' (url: ' + url + ')');
      }
    }

    // get exchangeInfo with caching
    async function getExchangeInfo(){
      const now = Date.now();
      if (cache.exchangeInfo.data && (now - cache.exchangeInfo.ts) < CACHE_TTL_MS) return cache.exchangeInfo.data;
      const data = await fetchJson(apiUrl('/fapi/v1/exchangeInfo'));
      cache.exchangeInfo = { ts: now, data };
      return data;
    }

    // get 24h tickers with caching
    async function get24hTickers(){
      const now = Date.now();
      if (cache.tickers24h.data && (now - cache.tickers24h.ts) < CACHE_TTL_MS) return cache.tickers24h.data;
      const data = await fetchJson(apiUrl('/fapi/v1/ticker/24hr'));
      cache.tickers24h = { ts: now, data };
      return data;
    }

    // ---------------- SMART TOP-10 UPDATE SYSTEM ----------------
async function updateTop10() {
  setStatus("Updating top 10…");

  try {
    // 1. Get all 24h tickers (1 lightweight call)
    const tickers = await fetchJson(apiUrl('/fapi/v1/ticker/24hr'));

    // 2. Filter perpetual USDT pairs only
    const exchangeInfo = await getExchangeInfo();
    const perpetualSet = new Set();
    for (const s of exchangeInfo.symbols || []) {
      if (s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT') && s.status === 'TRADING') {
        perpetualSet.add(s.symbol);
      }
    }

    const perps = tickers.filter(t => perpetualSet.has(t.symbol));

    // 3. Convert important numeric values
    for (const t of perps) {
      t.priceChangePercent = parseFloat(t.priceChangePercent);
      t.lastPrice = parseFloat(t.lastPrice);
      t.quoteVolume = parseFloat(t.quoteVolume);
      t.volume = parseFloat(t.volume);
    }

    // 4. Sort by 24h gain (DESCENDING) → REAL Top 10
    perps.sort((a,b) => b.priceChangePercent - a.priceChangePercent);

    const top10 = perps.slice(0, 10);

    // 5. Fetch extra lightweight data for each top 10 symbol
    const rows = [];
    for (let i = 0; i < top10.length; i++) {
      const t = top10[i];

      await pauseJitter(280, 420); // safer + lighter than full scan

      try {
        // Funding
        const premium = await fetchJson(apiUrl(`/fapi/v1/premiumIndex?symbol=${t.symbol}`));
        const fundingRate = parseFloat(premium.lastFundingRate ?? premium.fundingRate ?? 0);

        // OI
        const oi = await fetchJson(apiUrl(`/fapi/v1/openInterest?symbol=${t.symbol}`));
        const openInterest = parseFloat(oi.openInterest || 0);

        // 7-day klines (light enough for top 10 only)
        const klines = await fetchJson(apiUrl(`/fapi/v1/klines?symbol=${t.symbol}&interval=1d&limit=8`));
        let sevenDayPct = null;
        if (klines && klines.length >= 2) {
          const closeNow = parseFloat(klines[klines.length-1][4]);
          const close7ago = parseFloat(klines[0][4]);
          sevenDayPct = ((closeNow / close7ago) - 1) * 100;
        }

        rows.push({
          symbol: t.symbol,
          pct24h: t.priceChangePercent,
          pct7d: sevenDayPct,
          fundingRate,
          openInterest,
          volume: t.quoteVolume
        });
      } catch (err) {
        rows.push({ symbol: t.symbol, error: err.message });
      }
    }

    // 6. Render into the table (ONLY update tbody)
    const tbody = document.querySelector('#results tbody');
    tbody.innerHTML = '';

    for (const r of rows) {
      const tr = document.createElement('tr');

      tr.innerHTML = `
        <td><div class="badge">${r.symbol}</div></td>
        <td class="${r.pct24h >= 0 ? 'green' : 'red'}">${r.pct24h.toFixed(2)}%</td>
        <td>${r.pct7d ? r.pct7d.toFixed(2) + '%' : 'n/a'}</td>
        <td>${r.fundingRate.toFixed(6)}</td>
        <td>${Number(r.openInterest).toLocaleString()}</td>
        <td>${Number(r.volume).toLocaleString()}</td>
        <td><span class="badge">Updated</span></td>
      `;

      tbody.appendChild(tr);
    }

    setStatus("Top 10 updated ✓");
  } catch (e) {
    console.warn("updateTop10 error:", e);
    setStatus("Update error");
  }
}
// ------------------------------------------------------------

    // ------------------- AUTO REFRESH SYSTEM (GLOBAL) -------------------
let autoRefreshEnabled = false;
let autoTimer = null;

function startAutoRefresh() {
  if (autoRefreshEnabled) return;
  autoRefreshEnabled = true;

  async function loop() {
    if (!autoRefreshEnabled) return;

    await updateTop10(); // ✔ Only updates Top 10

    autoTimer = setTimeout(loop, 15000 + Math.random() * 10000); // 15–25s
  }

  loop();
}

function stopAutoRefresh() {
  autoRefreshEnabled = false;
  if (autoTimer) clearTimeout(autoTimer);
  autoTimer = null;
}
// --------------------------------------------------------------------

    // core scan function
    async function scan(){
      // enforce global cooldown
      const now = Date.now();
      if (now - lastScan < SCAN_COOLDOWN_MS) {
        const wait = Math.ceil((SCAN_COOLDOWN_MS - (now - lastScan)) / 1000);
        setStatus(`Cooldown active — wait ${wait}s`);
        return;
      }
      lastScan = now;

      // read thresholds
      const minDailyGainPct = parseFloat($('minDailyGain').value) || 3;
      const min7dGainPct = parseFloat($('min7dGain').value) || 7;
      const fundingThreshold = parseFloat($('fundingThreshold').value) || 0.001;
      let topN = parseInt($('topN').value) || 10;
      if (topN < 1) topN = 1;
      if (topN > 50) topN = 50; // safety cap

      resultsTbody.innerHTML = '';
      setStatus('Fetching exchangeInfo ...');
      const exchangeInfo = await getExchangeInfo();
      const perpetualSet = new Set();
      for (const s of exchangeInfo.symbols || []) {
        if (s.contractType === 'PERPETUAL' && s.symbol.endsWith('USDT') && s.status === 'TRADING') {
          perpetualSet.add(s.symbol);
        }
      }

      setStatus('Fetching 24h tickers ...');
      const tickers = await get24hTickers();
      const perps = (tickers || []).filter(t => perpetualSet.has(t.symbol));

      for (const t of perps) {
        t.priceChangePercent = parseFloat(t.priceChangePercent);
        t.lastPrice = parseFloat(t.lastPrice);
        t.quoteVolume = parseFloat(t.quoteVolume);
        t.volume = parseFloat(t.volume);
      }

      perps.sort((a,b) => b.priceChangePercent - a.priceChangePercent);
      const topGainers = perps.slice(0, Math.max(topN, 10)); // keep at least 10 shown for user expectation

      setStatus(`Top ${topGainers.length} gainers found — fetching details (safe mode) ...`);

      // For each top gainer, fetch klines (7d), premiumIndex (funding), openInterest
      const rows = [];
      for (let i = 0; i < topGainers.length; i++) {
        const t = topGainers[i];
        setStatus(`Fetching ${i+1}/${topGainers.length} — ${t.symbol}`);
        try {
          // Respectful jittered pause before per-symbol calls (reduces burst)
          await pauseJitter(350, 550);

          // 7-day klines: request 8 daily candles (today + 7 prev)
          const klines = await fetchJson(apiUrl(`/fapi/v1/klines?symbol=${t.symbol}&interval=1d&limit=8`));
          let sevenDayPct = null;
          if (klines && klines.length >= 2) {
            const closeNow = parseFloat(klines[klines.length-1][4]);
            const close7ago = parseFloat(klines[0][4]);
            sevenDayPct = ((closeNow / close7ago) - 1) * 100;
          }

          // funding (premiumIndex)
          const premium = await fetchJson(apiUrl(`/fapi/v1/premiumIndex?symbol=${t.symbol}`));
          const fundingRate = parseFloat(premium.lastFundingRate ?? premium.fundingRate ?? 0);

          // open interest (current)
          const oi = await fetchJson(apiUrl(`/fapi/v1/openInterest?symbol=${t.symbol}`));
          const openInterest = parseFloat(oi.openInterest || 0);

          rows.push({
            symbol: t.symbol,
            pct24h: t.priceChangePercent,
            pct7d: sevenDayPct,
            fundingRate,
            openInterest,
            volume: t.quoteVolume
          });
        } catch (err) {
          console.warn('Symbol error', t.symbol, err);
          rows.push({ symbol: t.symbol, error: err.message });
        }
      }

      // compute 7d ranking among results
      const valid7d = rows.filter(r => typeof r.pct7d === 'number' && !isNaN(r.pct7d));
      const sorted7d = [...valid7d].sort((a,b) => b.pct7d - a.pct7d);

      // render
      resultsTbody.innerHTML = '';
      for (const r of rows) {
        const tr = document.createElement('tr');

        const symTd = document.createElement('td');
        symTd.innerHTML = `<div style="display:flex;gap:8px;align-items:center">
          <div class="badge">${r.symbol}</div>
          ${r.error ? `<div class="small" style="color:#ffa">Error: ${r.error}</div>` : ''}
          </div>`;
        tr.appendChild(symTd);

        const pct24Td = document.createElement('td');
        pct24Td.textContent = (typeof r.pct24h === 'number' ? r.pct24h.toFixed(2) + '%' : 'n/a');
        pct24Td.className = (typeof r.pct24h === 'number' && r.pct24h > 0) ? 'green' : 'red';
        tr.appendChild(pct24Td);

        const pct7Td = document.createElement('td');
        pct7Td.textContent = (typeof r.pct7d === 'number' ? r.pct7d.toFixed(2) + '%' : 'n/a');
        tr.appendChild(pct7Td);

        const fundTd = document.createElement('td');
        fundTd.textContent = (typeof r.fundingRate === 'number' ? Number(r.fundingRate).toFixed(6) : 'n/a');
        tr.appendChild(fundTd);

        const oiTd = document.createElement('td');
        oiTd.textContent = (typeof r.openInterest === 'number' ? Number(r.openInterest).toLocaleString() : 'n/a');
        tr.appendChild(oiTd);

        const volTd = document.createElement('td');
        volTd.textContent = (r.volume ? Number(r.volume).toLocaleString() : 'n/a');
        tr.appendChild(volTd);

        // signals
        const signals = [];
        const minDailyGainPct = parseFloat($('minDailyGain').value) || 3;
        const min7dGainPct = parseFloat($('min7dGain').value) || 7;
        const fundingThreshold = parseFloat($('fundingThreshold').value) || 0.001;

        if (typeof r.pct24h === 'number' && r.pct24h >= minDailyGainPct) signals.push('High 24h gain');
        if (typeof r.pct7d === 'number' && r.pct7d >= min7dGainPct) signals.push('Strong 7d gain');
        const rank7 = r.pct7d ? (sorted7d.findIndex(x => x.symbol === r.symbol) + 1) : null;
        if (rank7 && rank7 <= Math.max(3, Math.ceil(valid7d.length * 0.3))) signals.push('Top 7d');
        if (typeof r.fundingRate === 'number' && r.fundingRate >= fundingThreshold) signals.push('Funding +');

        const sigTd = document.createElement('td');
        sigTd.innerHTML = signals.length ? signals.map(s=>`<span class="badge">${s}</span>`).join(' ') : '<span class="small">—</span>';
        tr.appendChild(sigTd);

        if (signals.length >= 3) {
          tr.classList.add('eup');
          sigTd.innerHTML = `<span class="badge eup">EUPHORIC</span> ` + sigTd.innerHTML;
        }

        resultsTbody.appendChild(tr);
      }

      setStatus('Scan complete — results shown. (Respect Binance rate limits; wait before re-scanning)');
    }

    // run button
    runBtn.addEventListener('click', async () => {
      runBtn.disabled = true;
      try {
        await scan();
      } catch (err) {
        setStatus('Error: ' + (err.message || err));
        console.error(err);
      } finally {
        runBtn.disabled = false;
      }
    });

    $('autoRefresh').addEventListener('change', e => {
  if (e.target.checked) {
    startAutoRefresh();
    setStatus('Auto-refresh enabled');
  } else {
    stopAutoRefresh();
    setStatus('Auto-refresh disabled');
  }
});

    // optional: auto-run once after load (commented)
    // (async()=>{ await scan(); })();

  })();
  </script>
</body>
</html>
